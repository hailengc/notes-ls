# 1	Introduction to Lesson 1


# 2	Lesson: Lecture 1

### Worldwind tour of a Rails app and basic scaffolding.

How Rails MVC handles processing a request and issuing a response.
  ![rails mvc](./request_response_mvc.jpg)

- bunlder, create sandbox per gemfile/project. 
  // bundle exec rake db:migrate ->  the specific version that your project depends on
  // rake db:migrate ->  the system level version
  // gemfile.lock

- files the rails new created
  - config/dababase.yml default is sqlite3 for dev, postgram for production
  - gemfile -> project file, whate gems I need
  - gemfile.loc -> generated when run bundle install
  - **routes.rb** -> routing 

- folder
  - app
    - asset (static asset, css,js,images,...)
    - **controller**
    - mailers -> not needed, but need a email provider
    - **models** -> 
    - **views** -> erb templates
  - bin -> where executabe sits, we never touch it
  - config
    - environments - first class in rails - override the appliation.rb
    - initializers -> be init before everything else
    - locales -> in yml files
  - boot.rb -> never touch, rails to boot itself
  - environment.rb -> 
  - db
    - migrate
  - lib 
    - asset > static asset
    - task
  - log
  - public
    - generic error pages,  static asset
    - robots.txt -> for search engine
  - test
  - tmp, cache,...
  - vendor > not really need, use bundler
  - config.ru x
  - rakefile x

**generator is not for experenced developers, build yourself**

`rake routes` to show all routes or `http://localhost:3000/rails/info/routes`

    ```
    D:\DEVEL\GitHub\notes-ls\301\pre\myapp>rake routes
      Prefix Verb   URI Pattern               Controller#Action
        posts GET    /posts(.:format)          posts#index
              POST   /posts(.:format)          posts#create
    new_post GET    /posts/new(.:format)      posts#new
    edit_post GET    /posts/:id/edit(.:format) posts#edit
        post GET    /posts/:id(.:format)      posts#show
              PATCH  /posts/:id(.:format)      posts#update
              PUT    /posts/:id(.:format)      posts#update
              DELETE /posts/:id(.:format)      posts#destroy  
  ```

controller/action -> render the view (name match)


### ActiveRecord 1:M

Active Record Pattern: how to abstract from database table into code. Object Relational Mapping (ORM). Rails impl the ORM in ruby

*OO -> SQL*

**foreign key** is always in the many side, occurs repeated

in `rails console`, `Post.first` translate into sql statement
```bash
irb(main):001:0> Post.first
  Post Load (0.0ms)  SELECT  "posts".* FROM "posts"  ORDER BY "posts"."id" ASC LIMIT 1
=> #<Post id: 1, title: "This is a post", url: "http://avcavc.com", description: "generated by rails controller, amazing...", created_at: "2017-04-20 23:55:46", updated_at: "2017-04-20 23:55:46">
```

> Exceptions: Save user info may save into different tables in different database, doesn't fit

controller
- plural

model
- singular

view
- controller as folder name
- action as file name

- irb with all active record loaded

> By convention in Rails, the table name should be the lowercase plural of the model name.

association
```ruby
class Post < ActiveRecord::Base
  belongs_to :user
end
class User < ActiveRecord::Base
  has_many :posts
end
```
- in many side: `has_many :posts`
- in 1 side: `belongs_to :user`
- virtual attributes, getter/setters for columns

- in memory object: id is nill
- in database: sql generated, begin/commit transaction, has id


# 3	Diagram: Rails Request/Response


# 4	Diagram: ActiveRecord Pattern


# 5	Diagram: 1:M Association


# 6	Diagram: M:M Association


# 7	Diagram: Entity Relationship Diagram


# 8	Assignment: Download the Project Template


# 9	Solution: System Check


# 10	Solution: Project Template


# 11	Assignment: Post model

1. First, create a migration to modify the database. In this migration, we want to create the table. Rails migrations are the only place where we want to use generators. Issue this command from the terminal within your project directory: `rails generate migration create_posts`

2. Open the newly created migration file in your code editor, and take a look at the migration file. Use the create_table method to create the necessary table and columns. We want: a url and title, which should both be strings and a description which should be text.

3. From the terminal again, issue this command: `rake db:migrate` (you may need to do rake db:create first, if you're using mysql or postgres). If you're getting a rake error, you can try adding `bundle exec` before the rake command.

4. Then take a look at your database and see that you have a posts table, with three columns: url, title and description.

5. Create a Post model file: under app/models directory, create a post.rb file put class Post < ActiveRecord::Base; end

6. Open rails console, and create your first Post object: `Post.create(title: "My first post", description: "I sure hope this works!", url: "www.yahoo.com")`. Verify by looking at your database that this worked.

snake_case for 

CamelCase for Model

# 12	Assignment: User model
# 13	Assignment: 1:M between User and Post
# 14	Assignment: Verify in "rails console"
# 15	Assignment: Comment model
# 16	Assignment: Comment associations
# 17	Assignment: Category model
# 18	Solution: Setting up the models
# 19	Solution: Pushing to Github

use generate only for migration

# 20	Lesson: Lecture 2

### migration

like sql schema, timestamped by generator

increamental, run it in order, no conflicts allowed, e.g.

order matters a lot, tracking in schema_migrations table, don't modify the table by hand


Migrations:
1. create posts table
2. add title column to posts (delete this, error occurs on 3)
3. remove title column to posts
4. create users table  (what if I want rename user to posters)

> never ever modify submitted migration files, prefer to add new migration

`reload!` in rails console reload the changes in data layer

- object to object // the virtual attributes
- id to id // the actualy column name


# 21	Assignment: M:M between Post and Category

habtm vs hmt

Database layer:
- join table

Model layer:

1. `has_and_belongs_to_many` 
- no join model
- implicit join table at db layer
  - `table1_name_table2_name` ex: `groups_users`
- Problems:
  - can't put additional attributes (columns) on association

2. `has_many` :through (**always preferred**)
- has a join model
- can put additional attributes (columns) on association


`tableize`

```
irb(main):021:0> "PostCategory".tableize
=> "post_categories"
```

### resouces and route

in routes.rb, `resources :posts` ~=

**memorise the mapping**

```
  # get   '/posts',          to: 'posts#index'
  # get   '/posts/:id',      to: 'posts#show'

  # get   '/posts/new',       to: 'psots#new'
  # post  '/posts',          to: 'posts#create'
  # get   '/posts/:id/edit', to: 'posts#edit'
  # patch '/posts/:id',      to: 'posts#update'
```

nested URL
  ```ruby
    resources :posts, except: [:destroy] do
      resources :comments, only: [:create]
    end
  ```

  ```
  post_comments_path	POST	/posts/:post_id/comments(.:format)	comments#create
  ```

name route
- build a link back to home page, 
- use name route rather than url which is a hard code string

```erb
# never ever use url
<%= link_to 'go back to all posts', '/posts' %>
# use name route
<%= link_to 'go back to all posts', posts_path %>
```

partial - reuse view
- 


# 22	Assignment: Verify with ERD Diagram


# 23	Solution: M:M Association


# 24	Assignment: Read ActiveRecord Association Methods doc


# 25	Assignment: Play with Associations


# 26	Assignment: Read Routes tutorial


# 27	Assignment: Read Layouts and Rendering


# 28	Assignment: resources :posts


# 29	Assignment: PostsController


# 30	Solution: Post resources


# 31	Assignment (optional): blog entry


# 32	Assignment (optional): change default association name


# 33	Assignment (optional): 1:M or M:M associations in the wild


# 34	Quiz: Lesson 1
# 35	Quiz: Lesson 1 Solution

1. Why do they call it a relational database?

We call it a relational database, because the tables within the database are associated with each other. This association can be created with primary/foreign keys and various syntax.

2. What is SQL?

SQL stands for "Structured Query Language" and it is used to manage the operations of a relational database.

3. There are two predominant views into a relational database. What are they, and how are they different?

The two predominant views are the data and schema views. Data view displays like a spreadsheet, with the table columns at the top and rows of data per each object instance.

A schema view shows us the column names and the value type of each column.

4. In a table, what do we call the column that serves as the main identifier for a row of data? We're looking for the general database term, not the column name.

We call this the "primary key".

5. What is a foreign key, and how is it used?

A foreign key is the identifier that connects an association with the models involved. The foreign key is always on the "many" side and is always in an integer type.

6. At a high level, describe the ActiveRecord pattern. This has nothing to do with Rails, but the actual pattern that ActiveRecord uses to perform its ORM duties.

ActiveRecord is a way to access the database. A database table is related to a class. An object of that class is created as a row in the table. This object can have different attribute values shown as the columns in the table. We can create, retrieve, update, and delete the object instances by altering the database table.

7. If there's an ActiveRecord model called "CrazyMonkey", what should the table name be?

By Rails convention, the table name should be "crazy_monkeys" by using "CrazyMonkey".tableize.

8. If I'm building a 1:M association between Project and Issue, what will the model associations and foreign key be?


```ruby
# In the Project model:
class Project < ActiveRecord::Base
  has_many :issues, foreign_key: :project_id
end

#In the Issue model:
class Issue < ActiveRecord::Base
  belongs_to :project, foreign_key: :project_id
end
```

The foreign key will be project_id.

9. Given this code
```ruby
class Zoo
  has_many :animals
end
```
What do you expect the other model to be and what does database schema look like?

```ruby
# The Animal model:
class Animal
  belongs_to :zoo
end
```

The database schema will have tables named:
- `zoos` table with a primary key of `id` 
- `animals` table with a primary key of `id` and foreign key of `zoo_id`

What are the methods that are now available to a zoo to call related to animals?
- `zoo.animals` will return all a list of all of the animals.
- `zoo.animals.first` will return the first row of data in the `animals` table. 

You can also iterate through the list of a zoo's animals and display certain properties of the animals.

How do I create an animal called "jumpster" in a zoo called "San Diego Zoo"?

```ruby
#In the Rails console, enter the following commands:
zoo = Zoo.create(name: 'San Diego Zoo')         # => Sets the primary id of 1 for San Diego Zoo
animal = Animal.create(name: 'jumpster', zoo_id: 1)

```


10. What is mass assignment? What's the non-mass assignment way of setting values?

Mass assignment allows us to assign multiple values to attributes with only a single assignment operator.

Mass assignment:
```ruby
Post.new(title: 'My first post', topic: 'Life')
Post.create(title: 'My first post', topic: 'Life')
```

Non-mass assignment:
```ruby
post = Post.new
post.title = 'My first post'
post.topic = 'Life'
```

11. What does this code do? Animal.first

This will return the first row of data for the first Animal instance object in the animals table.

12. If I have a table called "animals" with columns called "name", and a model called Animal, how do I instantiate an animal object with name set to "Joe". Which methods makes sure it saves to the database?

```ruby
animal = Animal.create(name: 'Joe')         # => Using "create" will hit the database and automatically saves it.
animal = Animal.new(name: 'Joe')            # => Using "new" will require you to use the save method afterwards to save it to the database.
animal.save
```

13. How does a M:M association work at the database level?

- On the database level of a M:M association, we use a join table to support it. Both of the primary models will each have a 1:M association with the join table.
- By using the has_many :through technique, we are able to create an indirect M:M association with the two primary models.

14. What are the two ways to support a M:M association at the ActiveRecord model level? Pros and cons of each approach?

- The two ways to support a M:M association are the `has_many :through` and `has_and_belongs_to_many` methods.
- `has_many :through` requires an explicit join model and a join table, but it is more flexible and we can add additional attributes to the join table.
- `has_and_belongs_to_many` doesn't require a join model but still requires a join table, but it is less flexible and we cannot add additional attributes to the join table.

> Note: always use `has many :through`, as `has_and_belongs_to_many` will be deprecated in the future.

15. Suppose we have a User model and a Group model, and we have a M:M association all set up. How do we associate the two?

We will need to use a join model(UserGroup) and table(user_groups) in this situation.

```ruby
# The User model:
class User < ActiveRecord::Base
    has_many :user_groups, foreign_key: :user_id
    has_many :groups, through: :user_groups
end

# The User_Group model:
class UserGroup < ActiveRecord::Base
    belongs_to :user, foreign_key: :user_id
    belongs_to :group, foreign_key: :group_id
end

# The Group model:
class Group < ActiveRecord::Base
    has_many :user_groups, foreign_key: :group_id
    has_many :users, through: :user_groups
end
```